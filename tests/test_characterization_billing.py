"""
Characterization tests for app.legacy.billing.compute_invoice_total

AUTO-GENERATED by Legacy Architect on 2025-12-26 00:40:50
DO NOT EDIT MANUALLY - These tests capture the current behavior of the legacy code.

Purpose: These tests verify that the refactored code produces IDENTICAL results
to the original legacy code. Any difference indicates a behavior change that needs
investigation.
"""

import os
import pytest
from app.legacy.billing import compute_invoice_total


class TestCharacterizationComputeInvoiceTotal:
    """Characterization tests capturing current behavior of compute_invoice_total."""
    

    def test_empty_order(self):
        """
        Empty order with no items
        
        Note: Edge case: no items
        """
        order = {
        "items": [],
        "state": "CA"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_single_physical_item_under_50(self):
        """
        Single physical item under $50 (shipping applies)
        
        Note: Subtotal < $50, so $5.99 shipping applies
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 25.0,
                        "type": "physical"
                }
        ],
        "state": "CA"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_single_physical_item_over_50(self):
        """
        Single physical item over $50 (free shipping)
        
        Note: Subtotal > $50, so free shipping
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 75.0,
                        "type": "physical"
                }
        ],
        "state": "CA"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_digital_only_order(self):
        """
        Digital-only order (no shipping)
        
        Note: Digital items never have shipping
        """
        order = {
        "items": [
                {
                        "name": "eBook",
                        "qty": 2,
                        "price": 15.0,
                        "type": "digital"
                }
        ],
        "state": "CA"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_mixed_physical_digital(self):
        """
        Mixed physical and digital items
        
        Note: Has physical items, so shipping rules apply
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 30.0,
                        "type": "physical"
                },
                {
                        "name": "eBook",
                        "qty": 1,
                        "price": 10.0,
                        "type": "digital"
                }
        ],
        "state": "CA"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_save10_coupon(self):
        """
        SAVE10 coupon (10% off)
        
        Note: 10% discount = $10 off
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "coupon": "SAVE10",
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_welcome5_coupon_eligible(self):
        """
        WELCOME5 coupon with subtotal > $20
        
        Note: $5 off because subtotal > $20
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 50.0,
                        "type": "physical"
                }
        ],
        "coupon": "WELCOME5",
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_welcome5_coupon_not_eligible(self):
        """
        WELCOME5 coupon with subtotal <= $20
        
        Note: No discount because subtotal <= $20
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 15.0,
                        "type": "physical"
                }
        ],
        "coupon": "WELCOME5",
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_half_coupon_under_cap(self):
        """
        HALF coupon under $50 cap
        
        Note: 50% of $60 = $30 discount (under $50 cap)
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 60.0,
                        "type": "physical"
                }
        ],
        "coupon": "HALF",
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_half_coupon_over_cap(self):
        """
        HALF coupon capped at $50
        
        Note: 50% of $200 = $100, but capped at $50
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 200.0,
                        "type": "physical"
                }
        ],
        "coupon": "HALF",
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_gold_member(self):
        """
        Gold member discount (2%)
        
        Note: 2% member discount = $2 off
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "member": "gold",
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_platinum_member(self):
        """
        Platinum member discount (5%)
        
        Note: 5% member discount = $5 off
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "member": "platinum",
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_coupon_plus_member(self):
        """
        Coupon and member discount combined
        
        Note: 10% coupon + 2% member = $12 total discount
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "coupon": "SAVE10",
        "member": "gold",
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_california_tax(self):
        """
        California tax rate (8.25%)
        
        Note: CA tax = 8.25%
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "state": "CA"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_new_york_tax(self):
        """
        New York tax rate (7%)
        
        Note: NY tax = 7%
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "state": "NY"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_texas_no_tax(self):
        """
        Texas - no tax
        
        Note: TX has no sales tax
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_default_state_tax(self):
        """
        Unknown state - default tax (5%)
        
        Note: Unknown state defaults to 5% tax
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "state": "FL"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_complex_order(self):
        """
        Complex order with everything
        
        Note: Multiple items, coupon, member discount, CA tax
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 3,
                        "price": 25.0,
                        "type": "physical"
                },
                {
                        "name": "Gadget",
                        "qty": 2,
                        "price": 15.0,
                        "type": "physical"
                },
                {
                        "name": "eBook",
                        "qty": 1,
                        "price": 9.99,
                        "type": "digital"
                }
        ],
        "coupon": "SAVE10",
        "member": "platinum",
        "state": "CA"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_multiple_quantities(self):
        """
        High quantity order
        
        Note: 10 x $5 = $50 subtotal (exactly at free shipping threshold)
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 10,
                        "price": 5.0,
                        "type": "physical"
                }
        ],
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    

    def test_zero_price_item(self):
        """
        Free item in order
        
        Note: Zero-price item shouldn't break calculation
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 30.0,
                        "type": "physical"
                },
                {
                        "name": "Free Sample",
                        "qty": 1,
                        "price": 0.0,
                        "type": "physical"
                }
        ],
        "state": "TX"
}
        
        # Get result from current implementation
        result = compute_invoice_total(order)
        
        # Verify structure
        assert "currency" in result
        assert "subtotal" in result
        assert "discount" in result
        assert "shipping" in result
        assert "tax" in result
        assert "total" in result
        
        # Verify total calculation
        expected_total = result["subtotal"] - result["discount"] + result["shipping"] + result["tax"]
        assert abs(result["total"] - expected_total) < 0.02, \
            f"Total mismatch: {result['total']} != {expected_total}"
        
        # Snapshot the current values (for documentation)
        # Subtotal: {result["subtotal"]}
        # Discount: {result["discount"]}
        # Shipping: {result["shipping"]}
        # Tax: {result["tax"]}
        # Total: {result["total"]}
    


class TestDualModeEquivalence:
    """
    Tests that verify BOTH modes (default and BILLING_V2) produce identical results.
    
    These tests are the heart of safe refactoring - they ensure the refactored
    code behind the feature flag behaves exactly like the original.
    """
    
    @pytest.fixture(autouse=True)
    def setup_teardown(self):
        """Save and restore BILLING_V2 env var."""
        original = os.environ.get("BILLING_V2")
        yield
        if original is None:
            os.environ.pop("BILLING_V2", None)
        else:
            os.environ["BILLING_V2"] = original
    

    def test_dual_mode_single_physical_item_under_50(self):
        """
        Verify default and BILLING_V2 modes produce identical results.
        
        Test case: Single physical item under $50 (shipping applies)
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 25.0,
                        "type": "physical"
                }
        ],
        "state": "CA"
}
        
        # Run in default mode
        os.environ.pop("BILLING_V2", None)
        result_default = compute_invoice_total(order)
        
        # Run in BILLING_V2 mode
        os.environ["BILLING_V2"] = "1"
        result_v2 = compute_invoice_total(order)
        
        # Both should produce identical results
        assert result_default == result_v2, \
            f"Mode mismatch:\nDefault: {result_default}\nV2: {result_v2}"
    

    def test_dual_mode_save10_coupon(self):
        """
        Verify default and BILLING_V2 modes produce identical results.
        
        Test case: SAVE10 coupon (10% off)
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "coupon": "SAVE10",
        "state": "TX"
}
        
        # Run in default mode
        os.environ.pop("BILLING_V2", None)
        result_default = compute_invoice_total(order)
        
        # Run in BILLING_V2 mode
        os.environ["BILLING_V2"] = "1"
        result_v2 = compute_invoice_total(order)
        
        # Both should produce identical results
        assert result_default == result_v2, \
            f"Mode mismatch:\nDefault: {result_default}\nV2: {result_v2}"
    

    def test_dual_mode_coupon_plus_member(self):
        """
        Verify default and BILLING_V2 modes produce identical results.
        
        Test case: Coupon and member discount combined
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 1,
                        "price": 100.0,
                        "type": "physical"
                }
        ],
        "coupon": "SAVE10",
        "member": "gold",
        "state": "TX"
}
        
        # Run in default mode
        os.environ.pop("BILLING_V2", None)
        result_default = compute_invoice_total(order)
        
        # Run in BILLING_V2 mode
        os.environ["BILLING_V2"] = "1"
        result_v2 = compute_invoice_total(order)
        
        # Both should produce identical results
        assert result_default == result_v2, \
            f"Mode mismatch:\nDefault: {result_default}\nV2: {result_v2}"
    

    def test_dual_mode_complex_order(self):
        """
        Verify default and BILLING_V2 modes produce identical results.
        
        Test case: Complex order with everything
        """
        order = {
        "items": [
                {
                        "name": "Widget",
                        "qty": 3,
                        "price": 25.0,
                        "type": "physical"
                },
                {
                        "name": "Gadget",
                        "qty": 2,
                        "price": 15.0,
                        "type": "physical"
                },
                {
                        "name": "eBook",
                        "qty": 1,
                        "price": 9.99,
                        "type": "digital"
                }
        ],
        "coupon": "SAVE10",
        "member": "platinum",
        "state": "CA"
}
        
        # Run in default mode
        os.environ.pop("BILLING_V2", None)
        result_default = compute_invoice_total(order)
        
        # Run in BILLING_V2 mode
        os.environ["BILLING_V2"] = "1"
        result_v2 = compute_invoice_total(order)
        
        # Both should produce identical results
        assert result_default == result_v2, \
            f"Mode mismatch:\nDefault: {result_default}\nV2: {result_v2}"
    
